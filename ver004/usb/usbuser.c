#include "stm32f10x.h"
#include "usbhw.h"
#include "usbcore.h"
#include "usbdesc.h"
#include "systimer.h"

// Чтобы инициализировать USB устройство необходимо вызвать функцию USB_HID_Init;

// Буферы для обмена данными с хостом
static uint8_t InBufEP1[BULK_IN_PACKET_SIZE];      // IN буфер (этот буфер изпользуется для передачи данных хосту)
static uint8_t OutBufEP1[BULK_OUT_PACKET_SIZE];    // OUT буфер (этот буфер изпользуется для приёма данных от хоста)


uint8_t *ToHostBufEP1 = &InBufEP1[0];               // Указатель на буфер, который будет передан хосту через конечную точку 1
uint16_t ToHostBufSize = BULK_IN_PACKET_SIZE;       // размер буфера для передачи данных хосту (один размер для всех конечных точек)
uint8_t ToHostBufFillEP1 = 0;                       // признак того, что буфер для хоста заполнен (для конечной точки 1)

uint8_t *FromHostBuf = &OutBufEP1[0];               // Указатель на буфер в который приходят данные от хоста
uint16_t FromHostBufSize = BULK_OUT_PACKET_SIZE;     // размер буфера для приёма данных от хоста
uint8_t FromHostBufFill = 0;                        // Признак того, что буфер от хоста заполнен данными


void USB_Init(void) // Инициализация и включение USB HID устройства
{
  // В качестве ног данных D+ и D- изпользуются PA11(D-) и  PA12(D+)

  RCC->APB1ENR |= RCC_APB1ENR_USBEN;  // Когда включается работа USB необходимые для его работы порт и ноги включаются и настраиваются сами автоматически
  NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);  // Разрешение прерывания от USB

  USB_Connect(1); // Функция инициализации подключения
}

void ClrFromHostBufFill(void) // Сброс признака "буфер полон" и разрешение работы точки
{
  FromHostBufFill = 0;
  USB_SetValidRX(0x01);
}

// Имя этой процедуры указанно в файле usbhw.c в массиве OnEndPointEvent, который хранит имена (адреса) функций, которые должны запуспаться при различных событиях с конечными точками
void EndPoint1Event(uint32_t event) // Событие от нулевой точки
{
  switch(event)
  {
    case USB_EVT_IN:  // Хост запрашивает данные
                      if(ToHostBufFillEP1) // Только когда данные заполнены их можно передавать хосту
                      {
                        // Передача пакета хосту
                        USB_WriteEP(0x81, &InBufEP1[0], BULK_IN_PACKET_SIZE);   // Передача пакета Хосту
                        ToHostBufFillEP1 = 0;                                   // Обнуляем признак того, что буфер заполнен
                        break;
                      }
                      USB_WriteEP(0x81, ((void *)0), 0); // Передача нулевого пакета Хосту (если передавать нечего)

                      break;

    case USB_EVT_OUT: // Хост выдаёт данные

                      if(FromHostBufFill)       // Если буфер заполнен, а хост опять прислал данные, то
                        USB_SetNAK(0x01);       // Отправка пакета неготовности приёма данных от хоста
                      else                      // иначе, если данные уже обработаны (буфер освободился). то
                      {
                        // Где-то на МК должен опрашиваться признак FromHostBufFill, если он выставляется в 1, то нужно обработать данные (опционально), и обязательно
                        // вызвать функцию ClrFromHostBufFill в этой функции конечная точка включиться и устройство снова будет готово принимать данные от хоста,
                        // в противном случае, попытка хостом передачи данных устройству будет вызывать ошибку

                        USB_ReadEP(0x01, &OutBufEP1[0]);  // Чтение данных из буфера
                        FromHostBufFill = 1;              // установка признака "Буфер заполнен"
                      }
                      break;

  }
}

